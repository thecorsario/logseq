---
title: Sep 24th, 2020
---

- ## 在MarginNote应用中打开该文档
  * c++ primer
    * 前言
        * 
  学习任何程序设计语言都需要编写程序。因此,本书提供了大量的示例。所有示例的源代码可从下列网址获得: http://www.awprofessional.com/cpp_primer
  * 
    * 第1章　[[快速入门]]
        * 
  本章介绍C++的大部分基本要素:内置类型、库类型、类类型、变量、表达式、语句和函数。在这一过程中还会简要说明如何编译和运行程序。
    * 1.1  编写简单的C++程序
        * 
  某书店以文件形式保存其每一笔交易。每一笔交易记录某本书的销售情况,含有ISBN(国际标准书号,世界上每种图书的唯一标识符)、销售册数和销售单价。每一笔交易形如-201-70353-X424。99 第一个元素是ISBN,第二个元素是销售的册数,最后是销售单价。店主定期地査看这个文件, 统计每本书的销售册数、总销售收入以及平均售价。我们要编写程序来进行这些计算。
        * 
  操作系统通过main函数返回的值来确定程序是否成功执行完毕。返回0值表明程序成功执行完毕
        * 
  定义函数必须指定4个元素:返回类型、函数名、圆括号内的形参表(可能为空)和函数体
    * 1.2.2  一个使用IO库的程序
        * 
  本书的大多数例子都使用了处理格式化输入和输出的 iostream库。
        * 
  一般情况下,系统将这些对象与执行程序的窗口联系起来。这样,当我们从cin读入时数据从执行程序的窗口读入,当写到cout、cerr或clog时,输出写至同一窗口。运行程序时, 大部分操作系统都提供了重定向输入或输出流的方法。利用重定向可以将这些流与所选择的文件联系起来。
        * 
  C++中,一个表达式由一个或几个操作数和通常是一个操作符组成。该语句的表达式使用输出操作符(<<操作符),在标准输出上输出提示语: std::cout <<"Enter two numbers: "<<std::endl; 这个语句用了两次输出操作符。每个输出操作符实例都接受两个操作数:左操作数必须是 ostream 对象:右操作数是要输出的值。操作符将其右操作数写到作为其左操作数的 ostream对象。
  C++中,每个表达式都会产生一个结果,通常是将操作符作用到其操作数所产生的值。当操作符是输出操作符时,结果是左操作数的值。也就是说,输出操作返回的值是输出流本身。
  既然输出操作符返回的是其左操作数,那么我们就可以将输出请求链接在一起。输出提示语的那条语句等价于(std::cout <<"Enter two numbers: “)<<std::endl 因为(std::cout<<"Enter two numbers:")返回其左操作数std::cout,这条语句等价于std: cout <<“Enter two numbers:”
   std: cout<<std: endl;
   endl是一个特殊值,称为操纵符( manipulator),将它写入输出流时,具有输出换行的效果并刷新与设备相关联的缓冲区(bufe)。通过刷新缓冲区,用户可立即看到写入到流中的输出。
        * 
  前缀std::表明cout和endl是定义在命名空间( namespace)std中的。使用命名空间,程序员可以避免由于无意中使用了与库中所定义名字相同的名字而引致冲突。
        * 
  输入操作符(>操作符)行为与输出操作符相似。它接受ー个 istream对象作为其左操作数, 接受一个对象作为其右操作数,它从 istream操作数读取数据并保存到右操作数中。像输出操作符一样,输入操作符返回其左操作数作为结果。由于输入操作符返回其左操作数,我们可以将输入请求序列合并成单个语句。换句话说,这个输入操作等价于输入操作的效果是从标准输入读取两个值,将第一个存放在v1中,第二个存放在v2中。
        * 
  给变量一个初始值几乎总是正确的,但不要求必须这样做。当我们确定变量在第一次使用时会赋一个新值,那就不需要创建初始值。例如,在本节开始我们的第一个有意义的程序中,定义了未初始化变量,并立即读取值给它们。
  定义变量时,应该给变量赋初始值,除非确定将变量用于其他意图之前会覆盖这个初值。
  如果不能保证读取变量之前重置变量,就应该初始化变量
    * 1.3  关于注释
        * 
  注释对不可嵌套
    * 1.4.1　while语句
        * 
  如果 condition为真(表达式求值不为零),则执行 while_ body_ statement。执行完后,再次测试 condition。如果 condition仍为真,则再次执行 while_body_ statemen 语句一直交替测试 condition和执行 while_ body_statement,直到 condition为假为止。
    * 1.4.2  for语句
        * 
  我们倾向于把确定函数边界的花括号自成一行,且编进复合的输入或输出表达式从而使操作符排列整齐,正如1,2节的main函数中的输出语白那样.随着程序的复杂化,其他缩排规范也会变得清晰。
        * 扼要重述一下,for循环总的执行流程为: (1)创建val并初始化为1。
  (2)测试va1是否小于或等于10。
  (3)如果va1小于或等于10,则执行for循环体,把val加到sum中。如果val大于10, 就退出循环,接着执行for语句体后的第一条语句。
  (4)va1递增
  (5)重复第2步的测试,只要条件为真,就继续执行其余步骤。 
    * 1.5.1  Sales_item类
        * 
  使用类时我们需要回答个问题(1)类的名字是什么? (2)它在哪里定义? (3)它支持什么操作? 对于书店问题,我们假定类命名为 Sales_item且类定义在命名为 Sales_iten.h的头文件中。
        * 
  正如我们所看到的,使用像IO一样的库工具,必须包含相关的头文件。类似地,对于自定义的类,必须使得编译器可以访问和类相关的定义。这几乎可以采用同样的方式。一般来说,我们将类定义放入一个文件中,要使用该类的任何程序都必须包含这个文件依据惯例,类类型存储在一个文件中,其文件名如同程序的源文件名一样,由文件名和文件后缀两部分组成。通常文件名和定义在头文件中的类名是一样的。通常后缀是.h,但也有一些程员用.H、.hpp或.hx。编译器通常并不挑别头文件名,但IDE有时会。假设我们的类定义在名为sale_iten.h的文件中。
        * 
  标准库的头文件用尖括号<>括起来,非标准库的头文件用双引号"“括起来。
    * 1.5.2  初窥成员函数
        * 
  调用命名为item1的 Sales_iten对象的成员函数( member function)。成员函数是由类定义的函数,有时称为类方法( method)
    * 1.6  C++程序
        * 
  该块输出适当的错误信息并退出程序, 返回-1。回想main函数的返回值被视为状态指示器:本例中,返回一个非零值表示程序未能产生期望的结果。
    * 术语
        * 
  本章介绍了足够多的cg知识,让读者能够编译和执行简单C—程序。我们看到了如何定义min函数,这是任何c—程序首先执行的函数。我们也看到了如何定义变量,如何进行输入和输出,以及如何编写if、 for和while语句,本章最后介绍c~最基本的工具:类。在这一章中,我们看到了如何创建和使用给定类的对象。后面的章节中将介绍如何自定义类。
        * 
  class(类)用于自定义数据结构的C++机制类是C++中最基本的特征。标准库类型,如istream和 ostream,都是类。
        * 
  data structure(数据结构)数据及数据上操作的逻辑组合。
        * 
  expression(表达式)最小的计算单元。表达式包含一个或多个操作数并经常含有一个操作符。表达式被求值并产生一个结果。例如, 假定主和j都为int型,则i+j是一个算术加法表达式并求这两个int值的和。表达式将在第5章详细介绍。
        * 
  manipulator (操纵符)在读或写时"操纵" 流本身的对象,如std: :endl. A.3.1节详细讲述操纵符。
        * 
  member function (成员函数)类定义的操作。成员函数通常在特定的对象上进行操作。
        * 
  main function(主函数)执行C+程序时, 操作系统调用的函数。每一个程序有且仅有个主函数main
        * 
  uninitialized variable(未初始化変量)没有指定初始值的变量。类类型没有未初始化变量。没有指定初始值的类类型变量由类定义初始化。在使用变量值之前必须给未初始化的变量赋值。未初始化变量是造成bug的主要原因之一
        * 
  () operator[()操作符]调用操作符。跟在函数名后且成对出现的圆括号。该操作符导致函数被调用,给函数的实参可在括号里传递。
        * 
  buit- in type(内置类型)C++语言本身定义的类型,如int
        * 
  buffer(缓冲区)一段用来存放数据的存储区域。IO设备常存储输入(或输出)到缓冲区, 并独立于程序动作对缓冲区进行读写。输出缓冲区通常必须显式刷新以强制输出缓冲区内容。默认情况下,读cin会刷新cout;当程序正常结束时,cout也被刷新。
    * 第2章　变量和基本类型
        * 
  C++语言定义了几种基本类型:字符型、整型、浮点型等。C++还提供了可用于自定义数据类型的机制,标准库正是利用这些机制定义了许多更复杂的类型,比如可变长字符串string、 vector等。
    * 2.1  基本内置类型
        * 
  C++定义了一组表示整数、浮点数、单个字符和布尔值的算术类型( arithmetic type),另外还定义了一种称为void的特殊类型。void类型没有对应的值,仅用在有限的一些情况下,通常用作无返回值函数的返回类型。
    * 2.1.1  整型
        * 
  让存储具有结构的最基本方法是用块(chunk)处理存储。大部分计算机都使用特定位数的块来处理存储,块的位数一般是2的幂,因为这样可以一次处理8、16或32位。64和128 位的块如今也变得更为普遍。虽然确切的大小因机器不同而不同,但是通常将8位的块作为个字节,32位或4个字节作为一个“字(word)”
    * 2.2  字面值常量
        * 
  像42这样的值,在程序中被当作字面值常量( literal constant)。称之为字面值是因为只能用它的值称呼它,称之为常量是因为它的值不能修改。每个字面值都有相应的类型,例如:0是int 型,3.14159是 double型。只有内置类型存在字面值,没有类类型的字面值。因此,也没有任何标准库类型的字面值
        * 
  定义字面值整数常量可以使用以下三种进制中的任一种:十进制、八进制和十六进制。当然这些进制不会改变其二进制位的表示形式。例如,我们能将值20定义成下列三种形式中的任意种
        * 
  通常可以用十进制或者科学计数法来表示浮点字面值常量。使用科学计数法时,指数用E 或者e表示。默认的浮点字面值常量为 double类型。在数值的后面加上F或f表示单精度。同样加上L或者1表示扩展精度(再次提醒,不提倡使用小写字母1)。下面每一组字面值表示相同的值:
        * 
  有些字符是不可打印的。不可打印字符实际上是不可显示的字符,比如退格或者控制符。还有一些在语言中有特殊意义的字符,例如单引号、双引号和反斜线符号。不可打印字符和特殊字符都用转义字符书写。转义字符都以反斜线符号开始,C++语言中定义了如下转义字符
        * 
  之前见过的所有字面值都有基本内置类型。还有一种字面值(字符串字面值)更加复杂。字符串字面值是一串常量字符,这种类型将在4.3节详细说明。
  字符串字面值常量用双引号括起来的零个或者多个字符表示。不可打印字符表示成相应的转义字符。
        * 为了兼容C语言,C++中所有的字符串字面值都由编译器自动在末尾添加一个空字符。字符字面值
  A / single quote character literal
  表示单个字符A,然而/ double quote: character string literal 表示包含字母A和空字符两个字符的字符串。
        * 
  使用了未定义行为的程序都是错误的,即使程序能够运行,也只是巧合。未定义行为源不幸的是,含有未定义行为的程序在有些环境或编译器中可以正确执行,但并不能保证同一程序在不同编译器中甚至在当前编译器的后继版本中会继续正确运行,也不能保证程序在一组输入上可以正确运行且在另一组输入上也能够正确运行程序不应该依赖未定义行为同样地,通常程序不应该依赖机器相关的行为,比如假定int的位数是个固定且已知的值,我们称这样的程序是不可移植的( nonportable)当程序移植到另一台机器上时,要寻找并更改任何依赖机器相关操作的代码。在本来可以运行的程序中寻找这类问题是一项非常不愉快的任务
    * 2.3.1  什么是变量
        * 
  C++是一门静态类型语言,在编译时会作类型检查在大多数语言中,对象的类型服制了对象可以执行的操作。如果某种类型不支持某种操作,那么这种类型的对象也就不能执行该操作。
  在C+中,操作是否合法是在编译时检查的。当编写表达式时,编译器检查表达式中的对象是否按该对象的类型定义的使用方式使用。如果不是的话,那么编译器会提示错误,而不产生可执行文件。
  随着程序和使用的类型变得越来越复杂,我们将看到静态类型检查能帮助我们更早地发现错误。静态类型检查使得编译器必须能识别程序中的每个实体的类型。因此,程序中使用变量前必须先定义变量的类型。
        * 
  变量提供了程序可以操作的有名字的存储区。C++中的每一个变量都有特定的类型,该类型决定了变量的内存大小和布局、能够存储于该内存中的值的取值范围以及可应用在该变量上的操作集。C++程序员常常把变量称为“变量”或“对象( object)”。
        * 
  我们在第5章再详细探讨表达式,现在先介绍C++的两种表达式: (1)左值( lvalue,发音为 ell-value):左值可以出现在赋值语句的左边或右边。
  (2)右值( rvalue,发音为are- value):右值只能出现在赋值的右边,不能出现在赋值语句的左边。
  变量是左值,因此可以出现在赋值语句的左边。数字字面值是右值,因此不能被赋值
        * 
  给定以下变量: int units sold = 0; double sales_price * 0, total_revenue = 0; 下列两条语句都会产生编译错误: / / error: arithmetic expression is not an Ivalue units_sold * sales_price = total_revenue; / / error: literal constant is not an Ivalue
  0 = 1；
        * 
  C++程序员经常随意地使用术语对象。一般而言,对象就是内存中具有类型的区域。说得更具体一些,计算左值表达式就会产生对象。
  严格地说,有些人只把术语对象用于描述变量或类类型的值。有些人还区别有名字的对象和没名字的对象,当谈到有名字的对象时一般指变量。还有一些人区分对象和值,用术语对象描述可被程序改变的数据,用术语值描述只读数据。
  在本书中,我们遵循更为通用的用法,即对象是内存中具有类型的区域。我们可以自由地使用对象描述程序中可操作的大部分数据,而不管这些数据是内置类型还是类类型,是有名字的还是没名字的,是可读的还是可写的
    * 2.3.2  变量名
        * 
        * 
  C++还保留了一些词用作各种操作符的替代名。这些替代名用于支持某些不支持标准C++操作符号集的字符集。它们也不能用作标识符。表2-3列出了这些替代名。
        * 
        * 
  变量名,即变量的标识符( identifier),可以由字母、数字和下划线组成
    * 2.3.3  定义对象
        * 
  初始化是创建变量并给他赋值
        * 
  每个类都可能会定义一个或几个特殊的成员函数(1.5.2节)来告诉我们如何初始化类类型的变量。定义如何进行初始化的成员函数称为构造函数( constructor)。和其他函数一样,构造函数能接受多个参数。一个类可以定义几个构造函数,每个构造函数必须接受不同数目或者不同类型的参数。
        * 
  每个定义都是以类型说明符(type specifier)开始,后面紧跟着以逗号分开的含有一个或多个说明符的列表。分号结束定义。
        * 
  变量定义指定了变量的类型和标识符,也可以为对象提供初始值。定义时指定了初始值的对象被称为是已初始化的( initialized)。C++支持两种初始化变量的形式:复制初始化(copy initialization)和直接初始化( direct-initialization)。复制初始化语法用等号(=),直接初始化则是把初始化式放在括号中:
    * 2.3.4  变量初始化规则
        * 
  内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成0,在函数体里定义的内置类型变量不进行自动初始化。除了用作赋值操作符的左操作数,未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难以发现。正如我们在2.2节劝告的,永远不要依赖未定义行为。
        * 
  如果定义某个类的变量时没有提供初始化式,这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即默认构造函数( default constructor)来实现的。这个构造函数之所以被称作默认构造函数,是因为它是“默认”运行的。如果没有提供初始化式,那么就会使用默认构造函数。不管变量在哪里定义,默认构造函数都会被使用。
  大多数类都提供了默认构造函数。如果类具有默认构造函数,那么就可以在定义该类的变量时不用显式地初始化变量。例如, string类定义了默认构造函数来初始化 string变量为空字符串,即没有字符的字符串:
   std:: string empty; / /empty is the empty string, empty = “”
   有些类类型没有默认构造函数。对于这些类型来说,每个定义都必须提供显式的初始化式。
  没有初始值是根本不可能定义这种类型的变量的。
    * 2.3.5  声明和定义
        * 变量的定义( definition)用于为变量分配存储空间,还可以为变量指定初始值。在一个程序中,变量有且仅有一个定义。
  声明( declaration)用于向程序表明变量的类型和名字。定义也是声明:当定义变量时我们声明了它的类型和名字。可以通过使用 extern关键字声明变量名而不定义它。不定义变量的声
  明包括对象名、对象类型和对象类型前的关键字 extern:
  extern声明不是定义,也不分配存储空间。事实上,它只是说明变量定义在程序的其他地方。
  程序中变量可以声明多次,但只能定义一次。
  只有当声明也是定义时,声明才可以有初始化式,因为只有定义才分配存储空间。初始化式必须要有存储空间来进斤初始化,如果声明有初始化式,那么它可被当作是定义,即使声明标记为 extern: 
  extern double pi = 3.1416; // definition
    * 2.3.6  名字的作用域
        * C++程序中,每个名字都与唯一的实体(比如变量、函数和类型等)相关联。尽管有这样的要求,还是可以在程序中多次使用同一个名字,只要它用在不同的上下文中,且通过这些上下文可以区分该名字的不同意义。用来区分名字的不同意义的上下文称为作用域( scope)。作用域是程序的一段区域。一个名称可以和不同作用域中的不同实体相关联。
  C++语言中,大多数作用域是用花括号来界定的。一般来说,名字从其声明点开始直到其声明所在的作用域结束处都是可见的。例如,思考1.4.2节中的程序:
  
  这个程序定义了三个名字,使用了两个标准库的名字。程序定义了一个名为main的函数,以及两个名为sum和val的变量。名字main定义在所有花括号之外,在整个程序都可见。定义在所有函数外部的名字具有全局作用域( global scope),可以在程序中的任何地方访问。名字sum定义在main函数的作用域中,在整个main函数中都可以访问,但在main函数外则不能。变量sum有局部作用域( local scope)。名字val更有意思,它定义在for语句的作用域中,只能在for语句中使用,而不能用在main函数的其他地方。它具有语句作用域( statement scope)。
    * 2.3.7  在变量使用处定义变量
        * 
  道常把一个对象定义在它首次使用的地方是一个很好的办法。
    * 2.4  const限定符
        * 
  第一个问题是程序的可读性。比较 index与512有什么意思呢?循环在做什么呢?也就是说512 作用何在?[本例中,512被称为魔数( magic number),它的意义在上下文中没有体现出来。好像这个数是魔术般地从空中出现的。
  第二个问题是程序的可维护性。假设这个程序非常庞大,512出现了100次。进一步假设在这100次中,有80次是表示某一特殊缓冲区的大小,剩余20次用于其他目的。现在我们需要把缓冲区的大小增大到1024。要实现这一改变,必须检査每个512出现的位置。我们必须确定(在每种情况下都准确地确定)哪些512表示缓冲区大小,而哪些不是。改错一个都会使程序崩溃, 又得回过头来重新检查
        * 
  与其他变量不同,除非特别说明,在全局作用域声明的 const变量是定义该对象的文件的局部变量。此变量只存在于那个文件中,不能被其他文件访问
  通过指定 const变量为 extern,就可以在整个程序中访问 const对象
    * 2.5  引用
        * 
  因为引用只是它绑定的对象的另一名字,作用在引用上的所有操作事实上都是作用在该引用绑定的对象上refval + 2: 将 refval指向的对象ival加2。类似地, int ii= refval 把和ival相关联的值赋给ii。
        * 
  引用( reference)就是对象的另一个名字。在实际程序中,引用主要用作函数的形式参数。
        * 
  const引用可以初始化为不同类型的对象或者初始化为右值(2.3.1节),如字面值常量:
        * 引用是种复合类型( compound type),通过在变量名前添加“&”符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下,每一种引用类型都“关联到”某一其他类型。不能定义引用类型的引用,但可以定义任何其他类型的引用。
  引用必须用与该引用同类型的对象初始化:
  
        * 
  C++程序员常常随意地使用术语 const引用。严格来说,“ const引用”的意思是“指向const对象的引用”。类似地,程序员使用术语“非 const引用”表示指向非 const类型的引用。这种用法非常普遍,我们在本书中也遵循这种用法
        * 
  观察将引用绑定到不同的类型时所发生的事情,最容易理解上述行为。假如我们编写
  double dval =3. 14 
  const int &ri dval 
  编译器会把这些代码转换成如以下形式的编码: 
  temp =dval //create temporary int from the double 
  const int &ri= temp //bind ri to that temporary 
  如果ri不是 const,那么可以给ri赋一新值。这样做不会修改dval,而是修改了 temp。期望对ri的赋值会修改dval的程序员会发现dval并没有被修改。仅允许 const引用绑定到需要临时使用的值完全避免了这个问题,因为 const引用是只读的。
    * 2.7  枚举
        * 
  typedef可以用来定义类型的同义词:
        * 
  typedef通常被用于以下三种目的: 为了隐藏特定类型的实现,强调使用类型的目的。
  简化复杂的类型定义,使其更易理解。
  允许一种类型用于多个目的,同时使得每次使用该类型的目的明确。
        * 
  枚举的定义包括关键字enum, 其后是一个可选的枚举类型名,和一个用花括号括起来、用逗号分开的枚举成员 (enumerator)列表。
  默认地,第一个枚举成员斌值为0 , 后面的每个枚举成员赋的值比前面的大1。
        * 
  可以为一个或多个枚举成员提供初始值,用来初始化枚举成员的值必须是一个常量表达式( constant expression)。常量表达式是编译器在编译时就能够计算出结果的整型表达式。整型字面值常量是常量表达式,正如一个通过常量表达式自我初始化的 const对象(2.4节)也是常量表达式样。
        * 
  本例中,枚举成员 point2a显式初始化为2。下个枚举成员 point2w默认初始化,即它的值比前一枚挙成员的值大1,因此 point2w初始化为3。枚举成员 point3a显式初始化为3。一样, point3w默认初始化,结果为4
        * 
  每个enum都定义了-种新的类型。和其他类型一样,可以定义和初始化 Points类型的对象,也可以以不同的方式使用这些对象。枚举类型的对象的初始化或赋值,只能通过其枚举成员或同一“枚举类型的其他对象来进行:
    * 2.8  类类型
        * 
  c++'|', 通过定义类(class)来自定义数据类型。类定义了该类型的对象包含的数据和该类想的对象可以执行的操作。标准库类型string、 istrem和ostrem都定义成类。
  C++对类的义持非常卞富——事实.h,定义类是如此重要,我们把第三到第五部分全部用来插述C++对类及炎操作的支持。
        * 
  每个类都定义了一个接口( interface)和一个实现( implementation)。接口由使用该类的代码需要执行的操作组成。实现一般包括该类所需要的数据。实现还包括定义该类需要的但又不供般性使用的函数。
  定义类时,通常先定义该类的接口,即该类所提供的操作。通过这些操作,可以决定该类完成其功能所需要的数据,以及是否需要定义一些函数来支持该类的实现。
        * 
  • 加法操作符,将两个sales_itm相加。
  • 输入和输出操作符,读和写sales_itm对象。
  • 赋值操作符,把sales_itm对象赋给另一个sales_itm对象。
  • sme_isbn函数,检测两个对象是否指同一本书,
        * 
  虽然现在不能实现这些函数,但通过思考这些操作必须要实现的功能,我们可以看出该类需要什么样的数据。 Sales_item类必须
  (1)记录特定书的销售册数。
  (2)记录该书的总销售收入。
  (3)计算该书的平均售价
        * 
  编程新手经常会忘记类定义后面的分号,这是个很普遍的错误
        * 
  访问标号负责控制使用该类的代码是否可以使用给定的成员。类的成员函数可以使用类的任何成员,而不管其访问级别。访问标号 public、 private可以多次出现在类定义中。给定的访问标号应用到下一个访问标号出现时为止。
  类中 public部分定义的成员在程序的任何部分都可以访问。一般把操作放在 public部分, 这样程序的任何代码都可以执行这些操作不是类的组成部分的代码不能访问 private成员。通过设定 Sales_iten的数据成员为private,可以保证对 Sales_item对象进行操作的代码不能直接操纵其数据成员。就像我们在第1章编写的程序那样,程序不能访问类中的 private成员。 Sales_item类型的对象可以执行那些操作,但是不能直接修改这些数据。
    * 2.9  编写自已的头文件
        * 
  为了允许把程序分成独立的逻辑块,C++支持所谓的分别编译( separate compilation)。这样程序可以由多个文件组成
        * 
  事实上,C++程序使用头文件包含的不仅仅是类定义。回想一下,名字在使用前必须先声明或定义。到目前为止,我们编写的程序是把代码放到一个文件里来处理这个要求。只要每个实体位于使用它的代码之前,这个策略就有效。但是,很少有程序简单到可以放置在一个文件中。由多个文件组成的程序需要一种方法连接名字的使用和声明,在C+中这是通过头文件实现的。
    * 2.9.1  设计自己的头文件
        * 
  头文件一般包含类的定义、 extern变量的声明和函数的声明。
        * 
  当设计头文件时,记住定义和声明的区别是很重要的。定义只可以出现一次,而声明则可以出现多次(2.3.5节)。下列语句是一些定义,所以不应该放在头文件里: extern int ival initializer, so it's a definition double fica rate; no extern, so it's a definition 虽然iva1声明为 extern,但是它有初始化式,代表这条语句是一个定义。类似地,fica_rate 的声明虽然没有初始化式,但也是一个定义,因为没有关键字 extern。同一个程序中有两个以上文件含有上述任一个定义都会导致多重定义链接错误
        * 
  对于头文件不应该含有定义这一规则,有三个例外。头文件可以定义类、值在编译时就已知道的 const对象和 inline函数(7.6节介绍 inline函数)。这些实体可在多个源文件中定义, 只要每个源文件中的定义是相同的。
        * 
  一般来说,常量表达式是编译器在编译时就能够计算出结果的表达式。当 const整型变量通过常量表达式自我初始化时,这个 const整型变量就可能是常量表达式。而 const变量要成为常量表达式,初始化式必须为编译器可见。为了能够让多个文件使用相同的常量值, . const 变量和它的初始化式必须是每个文件都可见的。而要使初始化式可见,一般都把这样的 const变量定义在头文件中。那样的话,无论该 const变量何时使用,编译器都能够看见其初始化式。
        * 
  这种行为有一个很重要的含义:当我们在头文件中定义了 const变量后,每个包含该头文件的源文件都有了自己的 const变量,其名称和值都一样
    * 2.9.2  预处理器的简单介绍
        * 
  预处理器用指定的头文件的内容替代每个#include。 
        * 
  使得头文件安全的通用做法,是使用预处理器定义头文件保护符( header guard)。头文件保护符用于避免在已经见到头文件的情况下重新处理该头文件的内容。
        * 
  为了保证头文件在给定的源文件中只处理过一次,我们首先检测# i indef。第一次处理头文件时,测试会成功,因为 SALESITEM H还未定义。下一条语句定义了 SALESITEM H。那样的话, 如果我们编译的文件恰好又一次包含了该头文件。# i indef指示会发现 SALESITEM H已经定义, 并且忽略该头文件的剩余部分。
        * 
  头文件应该包含保护符
        * 
  设计头文件时,应使其可以多次包含在同一源文件中,这一点很重要。我们必须保证多次包含同一头文件不会引起该头文件定义的类和对象被多次定义
    * 3.1  命名空间的的using声明
        * 
  这些名字都用了::操作符,该操作符是作用域操作符(1.2.2节)。它的含义是右操作数的名字可以在左操作数的作用域中找到。
        * 
  有一种情况下,必须总是使用完全限定的标准库名字:在头文件中。理由是头文件的内容会被预处理器复制到程序中。用# include包含文件时,相当于头文件中的文本将成为我们编写的文件的一部分。如果在头文件中放置 using声明,就相当于在包含该头文件的每个程序中都放置了同 using声明,不论该程序是否需要 using声明。
    * 3.2.1  string对象的定义和初始化
        * 
  因为历史原因以及为了与C语言兼容,字符串字面值与标准库 tring类型不是同一种类型这一点很容易引起混乱,编程时一定要注意区分字符串字面值和 string数据类型的使用, 这很重要
    * 第4章　数组和指针
        * 
  C++语言提供了两种类似于 vector和迭代器类型的低级复合类型一数组和指针。与vector类型相似,数组也可以保存某种类型的一组对象;而它们的区别在于,数组的长度是固定的。数组一经创建,就不允许添加新的元素。指针则可以像迭代器一样用于遍历和检査数组中的元素现代C++程序应尽量使用 vector和迭代器类型,而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。
    * 4.1.1  数组的定义和初始化
        * 
  与 vector类型相比,数组的显著缺陷在于:数组的长度是固定的,而且程序员无法知道个给定数组的长度。数组没有获取其容量大小的size操作,也不提供push_back操作在其中自动添加元素。如果需要更改数组的长度,程序员只能创建一个更大的新数组,然后把原数组的所有元素复制到新数组空间中去。
        * 
  数组的维数必须用值大于等于1的常量表达式定义(2.7节)。此常量表达式只能包含整型字面值常量、枚举常量(2.7节)或者用常量表达式初始化的整型 const对象。非 const变量以及要到运行阶段才知道其值的 const变量都不能用于定义数组的维数。
        * 
  如果没有显式提供元素初值,则数组元素会像普通变量一样初始化(2.3.4节): 
  在函数体外定义的内置数组,其元素均初始化为0 
  在函数体内定义的内置数组,其元素无初始化; 
  不管数组在哪里定义,如果其元素为类类型,则自动调用该类的默认构造函数进行初始化;如果该类没有默认构造函数,则必须为该数组的元素提供显式初始化。
    * 4.2.1  什么是指针
        * 
  第二条语句定义了一个指向 string类型的指针sp,并初始化sp使其指向 string类型的对象s *sp中的*操作符表明sp是一个指针变量,&s中的&符号是取地址( address-of)操作符,当此
  操作符用于一个对象上时,返回的是该对象的存储地址。取地址操作符只能用于左值(2.3.1节), 因为只有当变量用作左值时,才能取其地址。同样地,由于用于 vector类型、 string类型或内置数组的下标操作和解引用操作生成左值,因此可对这两种操作的结果做取地址操作,这样即可获取某一特定对象的存储地址。
    * 4.2.2  指针的定义和初始化
        * 
  实际上只把ps1定义为指针,而ps2并非指针,只是一个普通的 string对象而已。如果需要在个声明语句中定义两个指针,必须在每个变量标识符前再加符号*声明:
        * 
  就像使用其他没有初始化的变量一样,使用未初始化的指针时的行为C++标准中并没有定义，使用未初始化的指针,它几乎总会导致运行时崩溃。然而,导致崩溃的这一原因很难发现。
  r
        * 
  c++提供了一种特殊的指针类型void*,它可以保存任何类型对象的地址:
  void*指针只支持几种有限的操作:与另一个指针进行比较:向函数传递void*指针或从函数返回void*指针;给另一个void*指针赋值。不允许使用void*指针操纵它所指向的对象。我们将在5.12.4节讨论如何重新获取存储在void*指针中的地址。
        * 
  个有效的指针必然是以下三种状态之一:保存一个特定对象的地址;指向某个对象后面的另一对象;或者是0值。若指针保存0值,表明它不指向任何对象。未初始化的指针是无效的, 直到给该指针赋值后,才可使用它。下列定义和赋值都是合法的
        * 
  C++语言使用*符号把一个标识符声明为指针:
    * 4.2.3  指针操作
        * 
  虽然使用引用( reference)和指针都可间接访问另一个值,但它们之间有两个重要区别。第个区别在于引用总是指向某个对象:定义引用时没有初始化是错误的。第二个重要区别则是赋值行为的差异:给引用赋值修改的是该引用所关联的对象的值,而并不是使引用与另一个对象关联。引用一经初始化,就始终指向同一个特定对象(这就是为什么引用必须在定义时初始化的原因)。
    * 4.2.4  使用指针访问数组元素
        * 
  如果希望使指针指向数组中的另一个元素,则可使用下标操作符给某个元素定位,然后用取地址操作符&获取该元素的存储地址:
        * 
  与其使用下标操作,倒不如通过指针的算术操作( pointer arithmetic)来获取指定内容的存储地址。指针的算术操作和迭代器的算术操作(3.4.1节)以相同的方式实现(也具有相同的约東)。使用指针的算术操作在指向数组某个元素的指针上加上(或减去)一个整型数值,就可以计算出指向数组另一元素的指针值
    * 4.3  C风格字符串
        * 
  c—语言提供普通的关系操作符实现标准库类型string的对象的比较,这些操作符也可用于比较指向c风格字符串的指针,但效果却很不相同:实际上,此时比较的是指针上存放的地址值,而并非它们所指向的字符串:
    * 4.4  多维数组
        * 
  因为多维数组其实就是数组的数组,所以由多维数组转换而成的指针类型应是指向第一个内层数组的指针。尽管这个概念非常明了, 但声明这种指针的语法还是不容易理解:.
    * 5.8  sizeof操作符
        * 
  sizeof操作符的作用是返回一个对象或类型名的长度,返回值的类型为size_t( 3.5.2节), 长度的单位是字节(2.1节)。
        * 
  对数组做 sizeof操作等效于将对其元素类型做 sizeof操作的结果乘上数组元素的个数
    * 6.6.3  default标号
        * 
  defau1t标号( default label)提供了相当于e1se子句的功能。如果所有的case标号与switch表达式的值都不匹配,并且 defau1t标号存在,则执行 default标号后面的语句。例如, 在上述例子中添加一个计数器。 thercnt统计读入多少个辅音字母,为 switch i结构增加 default 标号,其标志的分支实现 etherent的自增:
    * 7.1  函数的定义
        * 
  函数由函数名以及一组操作数类型唯一地表示。函数的操作数,也即形参( parameter),在对圆括号中声明,形参与形参之间以逗号分隔。函数执行的运算在一个称为函数体(f Inchon body)的块语句中定义。每一个函数都有一个相关联的返回类型( return type)。
    * 7.1.1  函数返回类型
        * 
  类似于局部变量,函数的形参为函数提供了已命名的局部存储空间。它们之间的差别在于形参是在函数的形参表中定义的,并由调用函数时传递给函数的实参初始化。
  实参则是一个表达式。它可以是变量或字面值常量,甚至是包含一个或几个操作符的表达式在调用函数时,所传递的实参个数必须与函数的形参个数完全相同。与初始化式的类型必须与被初始化对象的类型匹配一样,实参的类型也必须与其对应形参的类型完全匹配:实参必须具有与形参类型相同、或者能隐式转换(5.12节)为形参类型的数据类型。本章7.8.2节将详细讨论实参与形参的匹配。
    * 7.2.1  非引用形参
        * 
  普通的非引用类型的参数通过复制对应的实参实现初始化。当用实参副本初始化形参时,函数并没有访问调用所传递的实参本身,因此不会修改实参的值。
        * 
  在调用函数时,如果该困数使用非引用的非const形参,则既可给该函数传递const实参也可传递非const的实参。例如,可以传递两个int型const对象调用gcd
        * 
  如果将形参定义为非引用的const笑型:
        * 
  则在函数中,不可以改变实参的局部副本。由于实参仍然是以副本的形式传递,因此传递给fcn 的既可以是 const对象也可以是非 const对象
    * 7.2.2  引用形参
        * 
  令人吃惊的是,尽管函数的形参是 const,但是编译器却将fcn的定义视为其形参被声明为普通的int型:
        * 
  复制实参并不是在所有的情况下都适合,不适宜复制实参的情况包括: 当需要在函数中修改实参的值时当需要以大型对象作为实参传递时。对实际的应用而言,复制对象所付出的时间和存储空间代价往往过大。
  当没有办法实现对象的复制时对于上述几种情况,有效的解决办法是将形参定义为引用或指针类型。
        * 
  在向函数传递大型对象时,需要使用引用形参,这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题,但是对于大部分的类类型或者大型数组,它的效率(通常)太低了;此外,我们将在第13章学习到,某些类类型是无法复制的。使用引用形参,函数可以直接访问实参对象,而无须复制它。
    * 7.2.5  传递给函数的数组的处理
        * 7.2.4  数组形参
            * 
  虽然不能直接传递数组,但是函数的形参可以写成数组的形式。虽然形参表示方式不同,但可将使用数组语法定义的形参看作指向数组元素类型的指针
    * 7.3.3  递归
        * 
  直接或间接调用自己的函数称为递归函数(wmiok function),
    * 7.5.2  静态局部对象
        * 
  在C++语言中,每个名字都有作用域,而每个对象都有生命期( lifetime)。要弄清楚函数是怎么运行的,理解这两个概念十分重要。名字的作用域指的是知道该名字的程序文本区。对象的生命期则是在程序执行过程中对象存在的时间。
  在函数中定义的形参和变量的名字只位于函数的作用域中:这些名字只在函数体中可见。通常,变量名从声明或定义的地方开始到包围它的作用域结束处都是可用的
        * 
  默认情况下,局部变量的生命期局限于所在函数的每次执行期间。只有当定义它的函数被调用时才存在的对象称为自动对象(automaticobjKt)。 自动对象在每次调用函数时创建和撤销
        * 
  个变量如果位于函数的作用域内,但生命期却跨越了这个函数的多次调用,这种变量往往很有用。则应该将这样的对象定义为 static(静态的)。
  static局部对象( static local object)确保不迟于在程序执行流程第一次经过该对象的定义语句时进行初始化。这种对象一旦被创建,在程序结束前都不会被撤销。当定义静态局部对象的函数结束时,静态局部对象不会撤销。在该函数被多次调用的过程中,静态局部对象会持续存在并保持它的值。考虑下面的小例子,这个函数计算了自己被调用的次数:
    * 7.6  内联函数
        * 
  为这样的小操作定义一个函数的好处是: • 阅读和理解函数shorterstring的调用,要比读一条用等价的条件表达式取代函数调用表达式并解释它的含义要容易得多。
  •如果需要做任何修改,修改函数要比找出并修改每一处等价表达式容易得多。
  • 使用函数可以确保统一的行为,每个测试都保证以相同的方式实现。
  • 困数可以重用,不必为其他应用重写代码。
        * 
  但是,将 shorterstring写成函数有一个潜在的缺点:调用函数比求解等价表达式要慢得多。在大多数的机器上,调用函数都要做很多工作:调用前要先保存寄存器,并在返回时恢复复制实参;程序还必须转向一个新位置执行。
    * 7.7  类的成员函数
        * 
  内联困数应该在头文件中定义,这一点不同于其他函数
    * 7.8.1  重载与作用域
        * 
  2.3.6节的程序演示了C++作用域的嵌套。在函数中局部声明的名字将屏蔽在全局作用域(2.3.6节)内声明的同名名字。这个关于变量名字的性质对于函数名同样成立
        * 
  一般的作用域规则同样适用于重载函数名。如果局部地声明1个函数,则该函数将屏蔽而不是重载在外层作用域中声明的同名困数。由此推论,每一个版本的重载函数都应在同一个作用域中声明
    * 7.8.3  重载确定的三个步骤
        * 
  匹配结果有三种可能: (1)编译器找到与实参最佳匹配( best match)的函数,并生成调用该函数的代码。
  (2)找不到形参与函数调用的实参匹配的函数,在这种情况下,编译器将给出编译错误信息。
  (3)存在多个与实参匹配的函数,但没有一个是明显的最佳选择。这种情况也是错误的,该调用具有二义性( ambiguous)。
  大多数情况下,编译器都可以直接明确地判断一个实际的调用是否合法,如果合法,则应该调用哪一个函数。重载集合中的函数通常有不同个数的参数或无关联的参数类型。当多个函数的形参具有可通过隐式转换(5.12节)关联起来的类型,则函数匹配将相当灵活。在这种情况下需要程序员充分地掌握函数匹配的过程
        * 
  1.候选函数
        * 
  2.选择可行函数
        * 
  3.寻找最佳匹配(如果有的话) 
        * 
  4.含有多个形参的重载确定
    * 7.8.4  实参类型转换
        * 
  为了确定最佳匹配,编译器将实参类型到相应形参类型的转换划分等级。转换等级以降序排列如下: (1)精确匹配( exact match)。实参与形参类型相同(2)通过类型提升( promotion)实现的匹配(5.12.2节) (3)通过标准转换( standard conversion)实现的匹配(5.12.3节)。
  (4)通过类类型转换( class-type conversion)实现的匹配(14.9节将介绍这类转换)
    * 7.9  指向函数的指针
        * 
  函数指针是指指向函数而非指向对象的指针。像其他指针一样,函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定,’而与函数名无关: 
    * 9.1.2  容器内元素的类型约束
    * 12.1.2  数据抽象和封装
        * 
  1.类成员
        * 
  2.构造函数
        * 
  3.成员函数
        * 
  类背后蕴涵的基本思想是数据抽象和封装数据抽象是一种依赖于接口和实现分离的编程(和设计)技术。类设计者必须关心类是如何实现的,但使用该类的程序员不必了解这些细节。相反,使用一个类型的程序员仅需了解类型的接口,他们可以抽象地考虑该类型做什么,而不必具体地考虑该类型如何工作。
  封装是一项将低层次的元素组合起来形成新的、高层次实体的技术。函数是封装的一种形式: 函数所执行的细节行为被封装在函数本身这个更大的实体中。被封装的元素隐藏了它们的实现细
        * 
  节一一可以调用一个函数但不能访问它所执行的语句。同样地,类也是一个封装的实体:它代表若干成员的聚集,大多数(良好设计的)类类型隐藏了实现该类型的成员。
        * 
  在C++中,使用访问标号(2.8节)来定义类的抽象接口和实施封装。一个类可以没有访问标号,也可以包含多个访问标号: •程序的所有部分都可以访问带有p&lic标号的成员。类型的数据抽象视图由其—lie 成员定义。
  •使用类的代码不可以访问带有private标号的成员。private封装了类型的实现细节。
  一个访问标号可以出现的次数通常是没有限制的。每个访问标号指定了随后的成员定义的访问级别。这个指定的访问级别持续有效,直至遇到下一个访问标号或看到类定义体的右花括号为止。
        * 
  程序员经常会将运行应用程序的人看作"用户"。应用程序为最终"使用”它的用户而设计, 并响应用户的反馈而完善。类也类似:类的设计者为类的"用户"设计并实现类。在这种情况下, "用户"是程序员,而不是应用程序的最终用户。
  成功的应用程序的创建者会很好地理解和实现用户的需求。同样地,良好设计的、实用的类, 其设计也要贴近类用户的需求。
  另一方面,类的设计者与实现者之间的区别,也反映了应用程序的用户与设计和实现者之间的区分。用户只关心应用程序能否以合理的费用满足他们的需求。同样地,类的使用者只关心它
        * 
  的接口。好的类设计者会定义直观和易用的类接口,而使用者只关心类中影响他们使用的那部分实现。如果类的实现速度太慢或给类的使用者加上负担,则必然引起使用者的关注。在良好设计的类中,只有类的设计者会关心实现。
  在简单的应用程序中,类的使用者和设计者也许是同一个人。即使在这种情况下,保持角色区分也是有益的。设计类的接口时,设计者应该考虑的是如何方便类的使用;使用类的时候,设计者就不应该考虑类如何工作。
        * 
  const成员不能改变其所操作的对象的数据成员。const必须同时出现在声明和定义中,若只出现在其中一处,就会出现一个编译时错误。
        * 
  将关键字const加在形参表之后,就可以将成员函数声明为常量:
    * 12.1.4  类声明与类定义
        * 
  且遇到右花括号,类的定义就结束了。并且一旦定义了类,那以我们就知道了所有的类成员,以及存储该类的对象所需的存储空间。在一个给定的源文件中,一个类只能被定义一次。如果在多个文件中定义一个类,那么每个文件中的定义必须是完全相同的。
    * 12.2  隐含的this指针
        * 
  在77.1节中已经提到,成员函数具有一个附加的隐含形参,即指向该类对象的一个指针。
  这个隐含形参命名为this,与调用成员函数的对象绑定在一起。成员函数不能定义this形参, 而是由编译器隐含地定义。成员函数的函数体可以显式使用this指针,但不是必须这么做。如果对类成员的引用没有限定,编译器会将这种引用处理成通过this指针的引用。
  1.何时使用亡hg指针尽管在成员函数内部显式引用this通常是不必要的,但有一种情况下必须这样做:当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最常见的情况是在这样的函数中使用this:该函数返回对调用该函数的对象的引用。
  某种类可能具有某些操作,这些操作应该返回引用, Screen类就是这样的一个类。迄今为止,我们的类只有一对get操作。逻辑上,我们可以添加下面的操作。
  对set操作,将特定字符或光标指向的字符设置为给定值。
  个move操作,给定两个 index值,将光标移至新位置。
  理想情况下,希望用户能够将这些操作的序列连接成一个单独的表达式:
        * 
  我们在2.8节中指出,类的定义以分号结束。分号是必需的,因为在类定义之后可以接一个对象定义列表。
        * 
  在单个表达式中调用move和set操作时,每个操作必须返回一个引用,该引用指向执行操作的那个对象:
        * 
  在普通的非const成员函数中,this的类型是一个指向类类型的const指针(4.2.5节)。
  可以改变this所指向的值,但不能改变this所保存的地址。在const成员函数中,this的类型是一个指向const类类型对象的const指针。既不能改变this所指向的对象,也不能改变this所保存的地址。
        * 
  问题在于这个表达式是在由displaY返回的对象上运行set。该对象是congt,因为display 将其对象作为const返回。我们不能在const对象上调用seto
        * 
  为了解决这个问题,我们必须定义两个 display操作:一个是 const,另一个不是 const。
  基于成员函数是否为 const,可以重载一个成员函数;同样地,基于一个指针形参是否指向 const (7.8.4节),可以重载一个函数。 const对象只能使用 const成员。非 const对象可以使用任一成员,但非 const版本是一个更好的匹配在此,我们将定义一个名为do_ display的 orivate成员来打印 Screen。每个 display操42作都将调用此函数,然后返回调用自己的那个对象:
        * 
  有时(但不是很经常),我们希望类的数据成员(甚至在 const成员函数内)可以修改。这可以通过将它们声明为 mutable来实现
    * 12.3  类作用域
        * 
  每个类都定义了自己的新作用域和唯一的类型。在类的定义体内声明类成员,将成员名引入类的作用域。两个不同的类具有两个不同的类作用域。
    * 12.4  构造函数
        * 
  构造函数(2.3.3节)是特殊的成员函数,只要创建类类型的新对象,都要执行构造函数。构造函数的工作是保证每个对象的数据成员具有合适的初始值
        * 
    * 12.4.4  隐式类—类型转换
    * 12.6  static类成员
        * 
  使用static成员而不是全局对象有三个优点。
  (1) static成员的名字是在类的作用域中,因此可以避免与其他类的成员或全局对象名字冲突。
  (2)可以实施封装。static成员可以是私有成员,而全局对象不可以。
  (3)通过阅读程序容易看出static成员是与特定类关联的。这种可见性可清晰地显示程序员的意图。
    * 12.6.2  static数据成员
        * 
  statie成员是类的组成部分但不是任何对象的组成部分,因此,static成员函数没有this 指针。通过使用非static成员显式或隐式地引用this是一个编译时错误。
  因为static成员不是任何对象的组成部分,所以static成员函数不能被声明为const.
  毕竟,将成资函数声明为const就是承诺不会修改该函数所属的对象。最后,static成员函数也不能被声明为虚函数。我们将在15.2.4节学习虚函数。
    * 13.2  赋值操作符
        * 
  赋值操作符
    * 13.3  析构函数
        * 
  构造函数的一个用途是自动获取资源。例如,构造函数可以分配一个缓冲区或打开一个文件, 在构造函数中分配了资源之后,需要一个对应操作自动回收或释放资源。析构函数就是这样的一个特殊函数,它可以完成所需的资源回收,作为类构造函数的补充
        * 
  撤销类对象时会自动调用析构函数:
        * 
  变量(如itm)在超出作用域时应该自动撤销。因此,当遇到右花括号时,将运行itm的析构函数。
  动态分配的对象只有在指向该对象的指针被删除时才撤销。如果没有删除指向动态对象的指针,则不会运行该对象的析构函数,对象就一直存在,从而导致内存泄漏,而且,对象内部使用的任何资源也不会择放。
        * 
  复制构造函数或赋值操作符不同,编译器总是会为我们合成一个析构函数。合成析构函数按对象剑建时的逆序撤销每个非statie成员,因此,它按成员在类中声明次序的逆序撤销成员。
        * 
  析构函数是个成员函数,它的名字是在类名字之前加上一个代字号(~), 它没有返回值,没有形参。因为不能指定任何形参,所以不能重载析构函数。
  虽然可以为一个类定义多个构造函数,但只能提供一个析构函数,应用于类的所有对象。
        * 
  撤销sdles_itm类型的对象时,将运行这个什么也不做的析构函数,它执行完毕后,将运行合成析构函数以撤销类的成员。合成析构函数调用string析构函数来撤销string成员,string 析构函数释放了保存isbn的内存。mits_sold和revenue成员是内置类型,所以合成析构函数撤销它们不需要做什么。
        * 
  许多类不需要显式析构函数,尤其是具有构造函数的类不一定需要定义自己的析构函数。仅在有些工作需要析构函数完成时,才需要析构函数。析构函数通常用于释放在构造函数或在对象生命期★获取的资源。
    * 13.4  消息处理示例
        * 
  有些类为了做一些工作需要对复制进行控制,为了给出这样的例子,我们将概略定义两个类, 这两个类可用于邮件处理应用程序。Messdge类和Folder类分别表示电子邮件(或其他)消息和消息所出现的目录,一个给定消息可以出现在多个目录中。Message上有save和Rmove操作,用于在指定Folder中保存或删除该消息。
  对每个Message,我们并不是在每个Folder中都存放一个副本,而是使每个Message保存一个指针集 (set), set中的指针指向该Message所在的Folder。 每个Folder也保存着一些指针,指向它所包含的Message。将要实现的数据结构如图13-1所示。
  创建新的Message时,将指定消息的内容但不指定Folder。调用save将Message放入一个Folder。
  复制一个Message对象时,将复制原始消息的内容和Folder指针集,还必须给指向源Mess- age的每个Folder增加一个指向该Message的指针。
  将一个Messdge对象赋值给另一个,类似于复制一个Message: 赋值之后,内容和Folder 集将是相同的。首先从左边Message在赋值之前所处的Folder中删除该Message。 原来的Message去掉之后,再将右边操作数的内容和Folder集复制到左边,还必须在这个Folder集中的每个Folder中增加一个指向左边Message的指针。
  撤销一个Message对象时,必须更新指向该Message的每个Folder。 一旦去掉了 Message, 指向该Message的指针将失效,所以必须从该Messdge的Folder指针集的每个Folder中删除这个指针。
    * 13.5  管理指针成员
        * 
  管理指针成员
    * 13.5.1  定义智能指针类
        * 
  定义智能指针的通用技术是来用一个使用计数(use count). 智能指针类将一个计数器与类指向的对象相关联。使用计数跟踪该类有多少个对象共享同一指针。使用计数为0时,删除对象。
  使用计数有时也称为引用计数(mferencecount)
    * 15.2.3  派生类
        * 
  尽管不是必须这样做,派生类一般会重定义所继承的虚函数。如果派生类没有重定义某个虚函数,则使用基类中定义的版本。
  派生类型必须对想要重定义的每个继承成员进行声明。Bu1l_item类指出,它将重定义met price函数但将使用book的继承版本派生类中虚函数的声明(74节)必须与基类中的定义方式完全匹配,但有一个例外:返回对基类型的引用(或指针)的虚函数。派生类中的虚函数可以返回基类函数所返回类型的派生类的引用(或指针)。
  例如, tem base类可以定义返回 Item base*的虚函数,如果这样,Bu1k_item类中定义『S64 的实例可以定义为返回 tem base*或Bu1 k-item*。159节将介绍这种虚函数的一个例子
    * 15.4.4  虚析构函数
        * 
  自动调用基类部分的析构函数对基类的设计有重要影响。
  删除指向动态分配对象的指针时,需要运行析构函数在释放对象的内存之前清除对象。处理继承层次中的对象时,指针的静态类型可能与被删除对象的动态类型不同,可能会删除实际指向派生类对象的基类类型指针。
  如果删除基类指针,则需要运行基类析构函数并清除基类的成员,如果对象实际是派生类型的,则没有定义该行为。要保证运行适当的析构函数,基类中的析构函数必须为虚函数:
    *
## (())